#include<bits/stdc++.h>
using namespace std;

static int const log32 (int n)
{
    double const log23 = 2.4663034623764317;
    return (int) ceil (log23 * log (n));
}

class Node
{
public:
    Node * left, *right, *parent;
    float value;
    Node ()
    {
        value = 0;
        left = right = parent = NULL;
    }
    Node (float v)
    {
        value = v;
        left = right = parent = NULL;
    }
};

int storeInArray (Node * ptr, Node * arr[], int i)
{
    if (ptr == NULL)
        return i;

    i = storeInArray (ptr->left, arr, i);
    arr[i++] = ptr;
    return storeInArray (ptr->right, arr, i);
}

class SGTree
{
private:
    Node * root;
    int n;
public:
    void preorder (Node *);
    int size (Node *);
    bool insert (float x);
    void rebuild (Node * u);
    SGTree ()       { root = NULL; n = 0; }
    void preorder () { preorder (root); }

    Node *Balancedtree (Node ** a, int i, int n);
    int BSTdelet(float z);
    int BSTInsert (Node * u);
    int search (float y);
    Node *delet (float z);
};

void SGTree::preorder(Node *node)
{
    if (node != NULL)
    {
        cout << node->value << " ";
        preorder(node -> left);
        preorder(node -> right);
    }
}

int SGTree::size (Node * node)
{
    if (node == NULL)
        return 0;
    return 1 + size (node->left) + size (node->right);
}

bool SGTree::insert(float x)
{
    Node *node = new Node(x);
  
    int h = BSTInsert(node);
  
    if (h > log32(n))
    {
        Node *p = node->parent;
        while (3*size(p) <= 2*size(p->parent))
            p = p->parent;
        rebuild(p->parent);
    }

    return h >= 0;
}

void SGTree::rebuild(Node *u)
{
    int n = size(u);
    Node *p = u->parent;
    Node **a = new Node* [n];
    storeInArray(u, a, 0);
    if (p == NULL)
    {
        root = Balancedtree(a, 0, n);
        root->parent = NULL;
    }
    else if (p->right == u)
    {
        p->right = Balancedtree(a, 0, n);
        p->right->parent = p;
    }
    else
    {
        p->left = Balancedtree(a, 0, n);
        p->left->parent = p;
    }
}

Node * SGTree::Balancedtree(Node **a,int i, int n)
{
    if (n== 0)
        return NULL;
    int m = n / 2;
  
    a[i+m]->left = Balancedtree(a, i, m);
  
    if (a[i+m]->left != NULL)
        a[i+m]->left->parent = a[i+m];
  
    a[i+m]->right =
         Balancedtree(a, i+m+1, n-m-1);
    if (a[i+m]->right != NULL)
        a[i+m]->right->parent = a[i+m];
  
    return a[i+m];
}

int SGTree::BSTInsert(Node *u)
{
    Node *w = root;
    if (w == NULL)
    {
        root = u;
        n++;
        return 0;
    }
  
    bool done = false;
    int d = 0;
    do
    {
        if (u->value < w->value)
        {
            if (w->left == NULL)
            {
                w->left = u;
                u->parent = w;
                done = true;
            }
            else
                w = w->left;
        }
        else if (u->value > w->value)
        {
            if (w->right == NULL)
            {
                w->right = u;
                u->parent = w;
                done = true;
            }
            else
                w = w->right;
        }
        else
            return -1;
        d++;
    }
    while (!done);
  
    n++;
    return d;
}

int SGTree::search (float y)
{
    Node *w = root;
    while (1)
    {
        if (w == NULL)
	    {
	        printf ("not found\n");
	        return 0;
	    }
        if (w->value == y)
	    {
	        printf ("found\n");
	        return 1;
	    }
        if (w->value < y)
	    w = w->right;
        if (w->value > y)
	    w = w->left;
    } 
}

int SGTree::BSTdelet(float z)
{
    Node* curr = root;
    Node* prev = NULL;
    while (curr != NULL && curr->value != z) {
        prev = curr;
        if (z < curr->value)
            curr = curr->left;
        else
            curr = curr->right;
    }
 
    if (curr == NULL) {
        cout << "Key " << z << " not found in the"
             << " provided BST.\n";
        return 0;
    }
 
    if (curr->left == NULL || curr->right == NULL) {
 
        Node* newCurr;
 
        if (curr->left == NULL)
            newCurr = curr->right;
        else
            newCurr = curr->left;
 
        if (prev == NULL)
            return 1;
 
        if (curr == prev->left)
            prev->left = newCurr;
        else
            prev->right = newCurr;
        free(curr);
    }
    else {
        Node* p = NULL;
        Node* temp;
 
        temp = curr->right;
        while (temp->left != NULL) {
            p = temp;
            temp = temp->left;
        }
 
        if (p != NULL)
            p->left = temp->right;
 
        else
            curr->right = temp->right;
 
        curr->value = temp->value;
        free(temp);
    }
    return 1;
}

Node*SGTree::delet(float z)
{
    int h=BSTdelet(z);
    if(h)
    {
      if (3*size(root)< 2*(8))
        rebuild(root);
    }
    return root;
}

int main ()
{
    float d;
    int s;
    char ch;
    SGTree sgt;
    while (1)
    {
        printf ("i) Insert :\ns) search :\nd) delete:\np) print preorder\nq) Quit:\nEnter char:");
        scanf ("%s", &ch);
        switch (ch)
	    {
	        case 'i':
                printf("Enter a data to insert:");
                scanf("%f",&d);
                sgt.insert(d);
                break;
            case 's':
                printf("Enter data you want to search:");
                scanf("%f",&d);
                s=sgt.search(d);
                break;
            case 'd':
                printf("Enter data you want to delete:");
                scanf("%f",&d);
                sgt.delet(d);
                break;
            case 'p':
                sgt.preorder();
                break;
            case'q':
                exit(0);
	    }
    }
}

